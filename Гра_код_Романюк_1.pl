перехід(0, 8, 1). 
перехід(1, 7, 1).
перехід(3, 8, 1). 
перехід(5, 6, 1). 
перехід(6, 8, 1). 
перехід(4, 9, 1).
перехід(2, 8, 2).
перехід(7, 3, 2). 
перехід(9, 8, 1). 
перехід(+, -, 1). 

% change(+Numb, +N, -Res, ++X) — Перевірка переходу
change(Numb, N, Res, X):- 
    перехід(Numb, Res, X), % Якщо існує перехід з стану Numb в стан Res за X сірників
    N+1 >= X. % І перевірка, чи можливий перехід, якщо N+1 (максимальна кількість сірників) більше або дорівнює X

% перетворення(+List, +Price, -Changes) — Трансформація списку
перетворення([], _, []):-!. % Якщо список порожній, результат також порожній
перетворення([H|T], Price, [[[]|L]|Changes]):- % Для кожного елемента списку H з решти T
    findall([Res,X], (перехід(H, Res, X), X > 0, Price+1 >= X), L), % Збирається список всіх можливих переходів з H, де X > 0 і Price+1 >= X
    перетворення(T, Price, Changes). % Рекурсивний виклик для залишкових елементів списку

% перетворення_обернене(+List, +Price, -Changes) — Обернена трансформація списку
перетворення_обернене([], _, []):-!. % Якщо список порожній, результат порожній
перетворення_обернене([H|T], Price, [[[]|L]|Changes]):- % Для кожного елемента списку H з решти T
    findall([Res,X], (перехід(Res, H, X), X > 0, Price+1 >= X), L), % Збирається список всіх можливих обернених переходів
    перетворення_обернене(T, Price, Changes). % Рекурсивний виклик для залишкових елементів списку

% список_в_вираз(+List, -Count, -Result) — Створення виразу зі списку
список_в_вираз([0|[_|_]], 0, ['false']):-!. % Якщо перший елемент 0, повертаємо 'false'
список_в_вираз([], 0, []):-!. % Якщо список порожній, повертаємо порожній список
список_в_вираз([H|T], Count, Res):- % Для кожного елемента списку
    H == null, % Якщо елемент == null, рекурсивно викликаємо список_в_вираз без змін
    список_в_вираз(T, Count, Res),!. 
список_в_вираз([H|T], 0, [H|Res]):- % Якщо Count == 0, додаємо елемент H до результату
    (H == '+'; H == '-'; H == '='), % Якщо елемент +, - або =, пропускаємо його
    список_в_вираз(T, _, Res),!. 
список_в_вираз([H|T], Count, Res):- % Якщо елемент не відповідає попереднім умовам
    список_в_вираз(T, Count1, R),
    ((Count1 =:= 0, список_в_вираз_0(H, R, Res)); % Якщо Count1 == 0, викликається список_в_вираз_0
    (Count1 > 0, список_в_вираз_1(H, R, Count1, Res))), % Інакше викликається список_в_вираз_1
    Count is Count1 + 1,!.

% список_в_вираз_0(+H, +List, -Result) — Додавання елемента в список
список_в_вираз_0(H, R, [H|R]):-!. % Додає елемент H до списку R

% список_в_вираз_1(+H, +List, +Count, -Result) — Обчислення числових виразів
список_в_вираз_1(H, [H1|T1], Count, [ResN|T1]):- 
    power10(Count, Powered), % Обчислює десяткову ступінь для чисел
    ResN is H * Powered + H1,!.

% power10(+Power, -Result) — Піднесення числа до степеня 10
power10(1, 10):-!. % 10^1 = 10
power10(Power, Res) :- 
    Power1 is Power - 1, % Зменшуємо степінь на 1
    power10(Power1, Res1), % Рекурсивно обчислюємо
    Res is 10 * Res1. % Результат множиться на 10 для кожного ступеня

% iss_list(+List) — Перевірка чи є список
iss_list([_]). % Якщо елемент — це одиничний список, то це список
iss_list([_|T]):- iss_list(T). % Рекурсивно перевіряємо, чи є список в решті елементів

% totobola(+List, -Result) — Обробка списків з перетином
totobola([],[]). % Порожній список на вході дає порожній список
totobola([H|T],[X|LR]):- iss_list(H), !, member(X,H), totobola(T,LR). % Якщо елемент є списком, шукаємо перетини
totobola([H|T],[H|LR]):- totobola(T,LR). % Якщо елемент не є списком, додаємо його до результату

% clear_price(+List, +Price, -Result) — Очищення за ціною
clear_price(L, P, R):- 
    findall(Res, (totobola(L, Res), sump(Res, N), N =:= P), R),!. % Збирає всі списки, де сума елементів дорівнює P

% sump(+List, -Sum) — Обчислення суми елементів
sump([], 0):-!. % Порожній список дає суму 0
sump([[]|T], R):- 
    sump(T, R),!. % Пропускаємо порожні списки
sump([[_|P]|T], R):- 
    sump(T, R1),
    R is R1 + P. % Додаємо суму елементів

% перетворення_виразу(+List, +Changes, -Result) — Трансформація виразу
перетворення_виразу([], [], []). % Якщо список порожній, результат порожній
перетворення_виразу([H|T], [[]|T1], [H|R]):- 
    перетворення_виразу(T, T1, R),!. % Якщо елемент порожній, додаємо його в результат
перетворення_виразу([_|T], [[Ch,_]|T1], [Ch|R]):- 
    перетворення_виразу(T, T1, R). % Перетворюємо вираз в результат

% arifm(+List) — Арифметичні операції
arifm([N1, =, N1]):-!. % Якщо рівняння виглядає як N1 = N1, нічого не змінюємо
arifm([N1|['-'|[N2|T]]]):-
    R is N1 - N2, % Віднімаємо N2 від N1
    arifm([R|T]),!. % Рекурсивно обчислюємо для залишкових елементів
arifm([N1|['+'|[N2|T]]]):-
    R is N1 + N2, % Додаємо N2 до N1
    arifm([R|T]). % Рекурсивно обчислюємо для залишкових елементів

% x(+List, +Price, +Changes, -Result)
x(L, P, Ch, R):- 
    clear_price(Ch, P, F), % Очищуємо за ціною
    member(X, F), % Знаходимо відповідні елементи
    перетворення_виразу(L, X, Res), % Трансформуємо вираз
    список_в_вираз(Res, _, R). % Формуємо остаточний результат

% розв(+List, +Price, -Result)
розв(L, P, R):- 
    перетворення(L, P, Ch), % Перетворюємо список за ціною
    x(L, P, Ch, R), % Обробляємо результат
    append(_, [E], R), % Додаємо елементи
    not(E == 'false'), % Перевірка на 'false'
    append(_, [S1|[S2,_]], R), % Перевірка на арифметичні операції
    not(((S1 == '+'; S1 == '-'; S1 == '='), (S2 == '+'; S2 == '-'; S2 == '='))), % Перевірка на арифметичні символи
    arifm(R). % Виконання арифметики

% генератор(+List, +Price, -Generated)
генератор(R, P, G):- 
    перетворення_обернене(R, P, Ch2), % Перетворення зворотне
    x(R, P, Ch2, G), % Обробка результату
    append(_, [E], G), % Додавання елементів
    not(E == 'false'). % Перевірка на 'false'

% гра(+List, +Price, -Results, -Generated)
гра(L, P, Res, Gen):- 
    findall(R, розв(L, P, R), Res), % Збираємо всі рішення
    findall(G, (member(R, Res), генератор(R, P, G)), Gen),!. % Генерація результатів для кожного рішення